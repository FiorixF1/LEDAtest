CubeMX su Windows ti genera del codice da usare per le periferiche, bello funzionante.
Scrivi il codice usando la libreria HAL.
Il CubeMX ti genera un makefile per fortuna.

Da Linux faccio make e quello risolve tutto (lì ho installato gcc per arm senza problemi).

Per flashare, ho sì installato stlink, ma in questa board puoi caricare il file dentro tipo chiavetta e stavolta FUNZIONA per davvero.

sudo screen /dev/ttyACM0 115200



libkeccak l'ho preso da qui, serve xsltproc
    git clone https://github.com/gvanas/KeccakCodePackage.git
    make | grep libkeccak
    make reference/libkeccak.a
Qui ti avrà generato libkeccak.a e la cartella degli header



Cosa ho fatto finora:
1) Con CubeMX ho generato uno stub di codice con UART e altre periferiche per poter lavorare.
2) Compilato libkeccak
    Dentro ToTargetMakefile.xsl modifica:
        MAKE ?= gmake
        CC = arm-none-eabi-gcc
        AR = arm-none-eabi-ar
    Dentro bin/.build/Makefile.expanded modifica:
        <h>lib/common/brg_endian.h</h>
        <gcc>-fomit-frame-pointer</gcc>
        <gcc>-O2</gcc>
        <gcc>-g0</gcc>
        <gcc>-mcpu=cortex-m4</gcc>
        <gcc>-mthumb</gcc>
        <gcc>-mfpu=fpv4-sp-d16</gcc>
        <gcc>-mfloat-abi=softfp</gcc>
    Compila con "make reference/libkeccak.a", quella non dovrebbe dare problemi perche' sostanzialmente compila senza usare i file ottimizzati.
        In quel caso devi solo mettere in giro le flag giuste e il compilatore ARM, poi funziona tutto.
    Ottieni libkeccak.a e libkeccak.a.headers: copiali dentro LEDAkem in include
3) Compilato LEDAcrypt gia' con i parametri necessari
    Modifica il Makefile per LEDAcrypt: inserisci arm-none-eabi-gcc, flag per il processore, -std=c11, CPU WORD BITS 32 !
        CC = arm-none-eabi-gcc 

        CFLAGS = -DCATEGORY=$(SL) -DN0=$(N0) -DCPU_WORD_BITS=32 \
                 -std=c11 -Wall -pedantic -Wmaybe-uninitialized -Wuninitialized \
                 -O3 -g3 -mcpu=cortex-m4 -mthumb -mfpu=fpv4-sp-d16 -mfloat-abi=softfp \
                 --specs=rdimon.specs -Wl,--start-group -lgcc -lc -lm -lrdimon -lnosys -Wl,--end-group
        LDFLAGS = -lm -lkeccak
        INCLUDES = -I./include -I./include/libkeccak.a.headers
        SRCDIR = library
        OBJDIR = bin
4) Modificato il make di CubeMX per inserirci le librerie varie, cambiato la FPU da hard a soft, inserito i parametri di LEDAcrypt, guardalo insomma
5) Fatto un main per testare con output KAT-compliant
6) Scritto uno script bash + Python per compilare velocemente in x86 e testare i KAT
7) Nella libreria modificati i file
    - gf2x_xPplusOne.h: definizioni di due costanti nuove
    - api.h: prototipi di due nuove funzioni e modificate le lunghezze degli array
    - kem.c: implementate quelle due funzioni, necessarie per generare uno shared secret su ARM uguale a quello previsto su x64



Situazione attuale:
- Le primitive funzionano
- Non c'e' clock_gettime() in rng.c
- Creato qualche script bash per compilare velocemente
- Creato script Python per testare i KAT e, grazie alle funzioni di serializzazione, PASSANO TUTTI
    Tuttavia e' testato su x86, dovrei cercare di farlo sul controllore gestendo la seriale che un po' e' rognosa
- Nuovo main che gestisce anche i numeri casuali come seed, pero' sull'altra board



OpenOCD non installarlo con apt-get perche' non funziona nulla, ricompilalo da zero da Github https://github.com/ntfreak/openocd
openocd -f tcl/board/st_nucleo_f4.cfg

target remote :3333
file ./build/LEDAtest.elf <- per avere simboli di debug
monitor reset halt





INVIARE DATI SULLA SERIALE
    Usa lo script UART.py
RICEVERE DATI SULLA SERIALE
    Usa cat /dev/ttyACM0 > file
    MA QUESTO SI FERMA
    Prova questo
awk `
/EOF/ {exit;} 
 {print;}` < /dev/ttyUSB0 > file.txt
E alla fine lavori sul file
